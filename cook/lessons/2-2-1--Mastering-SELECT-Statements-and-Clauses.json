{
  "object": [
    [
      {
        "type": "TUTORIAL",
        "title": "Introduction to SELECT Statements",
        "body": "In this lesson, we start by exploring the anatomy of a basic `SELECT` statement. The `SELECT` clause is used to specify which columns to retrieve, and it is the foundation of any query. Typically, a simple query looks like this:\n\n```sql\nSELECT column1, column2\nFROM table_name;\n```\n\nNotice that the `SELECT` clause is mandatory, while other clauses such as `FROM`, `WHERE`, `GROUP BY`, and `ORDER BY` are optional based on the complexity of the query.\n\nUnderstanding the placement and role of these clauses is crucial for building effective queries."
      },
      {
        "type": "EXAMPLE",
        "body": "Imagine you have a table called `employees` with columns `first_name`, `last_name`, and `department`. To retrieve first and last names, you would write:\n\n```sql\nSELECT first_name, last_name\nFROM employees;\n```",
        "answer": "This query retrieves the `first_name` and `last_name` columns from the `employees` table. It demonstrates the basic structure of a SELECT statement where the `FROM` clause tells the database which table to query."
      },
      {
        "type": "QUESTION",
        "question": "Which clause is mandatory in every SQL query that retrieves data?",
        "alternatives": [
          {
            "order": 1,
            "content": "SELECT",
            "explanation": "Correct. The SELECT clause is required to specify the columns to be retrieved."
          },
          {
            "order": 2,
            "content": "FROM",
            "explanation": "Incorrect. Although common, the FROM clause is not mandatory in queries that do not reference a table (e.g., selecting a literal)."
          },
          {
            "order": 3,
            "content": "WHERE",
            "explanation": "Incorrect. The WHERE clause is optional and is used to filter the result set."
          },
          {
            "order": 4,
            "content": "ORDER BY",
            "explanation": "Incorrect. The ORDER BY clause is optional and used to sort the results."
          }
        ],
        "correctAlternativeOrder": 1
      },
      {
        "type": "QUESTION",
        "question": "What is the primary purpose of the DISTINCT keyword in a SELECT statement?",
        "alternatives": [
          {
            "order": 1,
            "content": "To eliminate duplicate rows from the result set.",
            "explanation": "Correct. DISTINCT ensures that only unique rows are returned."
          },
          {
            "order": 2,
            "content": "To sort the result set.",
            "explanation": "Incorrect. Sorting is the function of the ORDER BY clause."
          },
          {
            "order": 3,
            "content": "To filter rows based on a condition.",
            "explanation": "Incorrect. Filtering is done via the WHERE clause."
          },
          {
            "order": 4,
            "content": "To group rows for aggregation.",
            "explanation": "Incorrect. Grouping is achieved using the GROUP BY clause."
          }
        ],
        "correctAlternativeOrder": 1
      },
      {
        "type": "TUTORIAL",
        "title": "Exploring Advanced SELECT Clauses: GROUP BY and ORDER BY",
        "body": "Beyond the basic SELECT-FROM construct, SQL provides additional clauses to further refine your queries.\n\n- **GROUP BY**: This clause is used to arrange identical data into groups so that aggregate functions (such as COUNT, SUM, AVG) can be applied to each group.\n- **ORDER BY**: This clause sorts the resulting data in ascending (ASC) or descending (DESC) order.\n\nFor example, if you want to see the number of employees per department in a company, you can group the data by department and count the employees."
      },
      {
        "type": "EXAMPLE",
        "body": "Consider a table `sales` with columns `region` and `sales_amount`. To find the total sales amount per region and sort the regions by total sales, the query would be:\n\n```sql\nSELECT region, SUM(sales_amount) AS total_sales\nFROM sales\nGROUP BY region\nORDER BY total_sales DESC;\n```",
        "answer": "This query selects the `region` and computes the total sales for each region using the SUM function. It groups the data by `region` and then orders the results in descending order based on the total sales."
      },
      {
        "type": "QUESTION",
        "question": "What is the role of the GROUP BY clause in a SELECT statement?",
        "alternatives": [
          {
            "order": 1,
            "content": "To arrange rows into groups for aggregate calculations.",
            "explanation": "Correct. GROUP BY is used to group rows so that aggregate functions can be applied to each group."
          },
          {
            "order": 2,
            "content": "To filter rows before aggregation.",
            "explanation": "Incorrect. Filtering rows is performed by the WHERE clause."
          },
          {
            "order": 3,
            "content": "To sort the results.",
            "explanation": "Incorrect. Sorting the results is the task of the ORDER BY clause."
          },
          {
            "order": 4,
            "content": "To remove duplicate results.",
            "explanation": "Incorrect. Removing duplicates is done using the DISTINCT keyword."
          }
        ],
        "correctAlternativeOrder": 1
      },
      {
        "type": "QUESTION",
        "question": "When should the ORDER BY clause be used in a SELECT query?",
        "alternatives": [
          {
            "order": 1,
            "content": "When you need to sort the result set based on one or more columns.",
            "explanation": "Correct. ORDER BY is used to determine the order in which the rows are returned."
          },
          {
            "order": 2,
            "content": "To group rows based on column values.",
            "explanation": "Incorrect. Grouping is handled by the GROUP BY clause."
          },
          {
            "order": 3,
            "content": "To filter rows according to a condition.",
            "explanation": "Incorrect. Filtering is performed with the WHERE clause."
          },
          {
            "order": 4,
            "content": "To eliminate duplicate entries.",
            "explanation": "Incorrect. Using DISTINCT removes duplicates, not ORDER BY."
          }
        ],
        "correctAlternativeOrder": 1
      },
      {
        "type": "EXAMPLE",
        "body": "Let's combine multiple clauses together. Suppose you have a `students` table with columns `name`, `grade`, and `subject`. To select distinct subjects, count the number of students per subject, and list them in alphabetical order, you could write:\n\n```sql\nSELECT DISTINCT subject, COUNT(name) AS student_count\nFROM students\nGROUP BY subject\nORDER BY subject ASC;\n```",
        "answer": "This query demonstrates the use of DISTINCT along with GROUP BY and ORDER BY. The DISTINCT ensures that each subject is unique, while COUNT aggregates the number of students per subject, and ORDER BY arranges the subjects alphabetically."
      },
      {
        "type": "TUTORIAL",
        "title": "Common Pitfalls and Optimization Strategies",
        "body": "Even though constructing a SELECT query might seem straightforward, there are common pitfalls to watch out for:\n\n- **Clause Order**: Remember, the proper order is: SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY, and sometimes LIMIT.\n- **Ambiguous Column References**: When joining tables, always qualify your column names.\n- **Overusing DISTINCT**: While DISTINCT can help remove duplicates, excessive use may impact performance.\n\nBy understanding these elements, you can avoid common mistakes and optimize your queries for better performance."
      },
      {
        "type": "QUESTION",
        "question": "Consider the following query snippet. What is a potential issue if the query involves multiple tables without explicit aliasing?\n\n```sql\nSELECT name, COUNT(*)\nFROM orders, customers\nWHERE orders.customer_id = customers.id\nGROUP BY name;\n```\n\nChoose the best explanation.",
        "alternatives": [
          {
            "order": 1,
            "content": "The query may produce ambiguous column references since 'name' might exist in more than one table.",
            "explanation": "Correct. Without table aliases, the database may not know which 'name' column to use if multiple tables have a column with that name."
          },
          {
            "order": 2,
            "content": "The query is missing the DISTINCT keyword.",
            "explanation": "Incorrect. DISTINCT is not required here, as the issue lies in ambiguous references rather than duplicate rows."
          },
          {
            "order": 3,
            "content": "The GROUP BY clause is incorrectly placed.",
            "explanation": "Incorrect. The GROUP BY clause placement is proper; the problem is with ambiguous column identification."
          },
          {
            "order": 4,
            "content": "The WHERE clause should come after GROUP BY.",
            "explanation": "Incorrect. The WHERE clause is correctly placed before GROUP BY. The issue remains with ambiguity in the column 'name'."
          }
        ],
        "correctAlternativeOrder": 1
      }
    ]
  ],
  "finishReason": "stop",
  "usage": {
    "promptTokens": 3853,
    "completionTokens": 3007,
    "totalTokens": 6860
  },
  "warnings": [
    {
      "type": "unsupported-setting",
      "setting": "temperature",
      "details": "temperature is not supported for reasoning models"
    }
  ],
  "providerMetadata": {
    "openai": {
      "reasoningTokens": 960,
      "acceptedPredictionTokens": 0,
      "rejectedPredictionTokens": 0,
      "cachedPromptTokens": 0
    }
  },
  "experimental_providerMetadata": {
    "openai": {
      "reasoningTokens": 960,
      "acceptedPredictionTokens": 0,
      "rejectedPredictionTokens": 0,
      "cachedPromptTokens": 0
    }
  },
  "response": {
    "id": "chatcmpl-B3F6ILyb5cQISYL5yhiXjxgqECJeI",
    "timestamp": "2025-02-21T04:38:50.000Z",
    "modelId": "o3-mini-2025-01-31",
    "headers": {
      "access-control-expose-headers": "X-Request-ID",
      "alt-svc": "h3=\":443\"; ma=86400",
      "cf-cache-status": "DYNAMIC",
      "cf-ray": "91540c93887a5000-LIM",
      "connection": "keep-alive",
      "content-encoding": "br",
      "content-type": "application/json",
      "date": "Fri, 21 Feb 2025 04:39:05 GMT",
      "openai-organization": "rh-18",
      "openai-processing-ms": "14948",
      "openai-version": "2020-10-01",
      "server": "cloudflare",
      "strict-transport-security": "max-age=31536000; includeSubDomains; preload",
      "transfer-encoding": "chunked",
      "x-content-type-options": "nosniff",
      "x-ratelimit-limit-requests": "5000",
      "x-ratelimit-limit-tokens": "4000000",
      "x-ratelimit-remaining-requests": "4999",
      "x-ratelimit-remaining-tokens": "3973050",
      "x-ratelimit-reset-requests": "12ms",
      "x-ratelimit-reset-tokens": "404ms",
      "x-request-id": "req_7574a0cf0afce87ca9007153c9ff0e85",
      "set-cookie": "_cfuvid=ZSIbk.lLVnWjRdS8Lwd.kCketik5WaytFeX.37TJnjk-1740112745484-0.0.1.1-604800000; path=/; domain=.api.openai.com; HttpOnly; Secure; SameSite=None"
    }
  },
  "request": {
    "body": "{\"model\":\"o3-mini\",\"response_format\":{\"type\":\"json_schema\",\"json_schema\":{\"schema\":{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"elements\":{\"type\":\"array\",\"items\":{\"type\":\"array\",\"items\":{\"anyOf\":[{\"type\":\"object\",\"properties\":{\"type\":{\"type\":\"string\",\"const\":\"TUTORIAL\"},\"title\":{\"type\":\"string\"},\"body\":{\"type\":\"string\"}},\"required\":[\"type\",\"title\",\"body\"],\"additionalProperties\":false},{\"type\":\"object\",\"properties\":{\"type\":{\"type\":\"string\",\"const\":\"EXAMPLE\"},\"body\":{\"type\":\"string\"},\"answer\":{\"type\":\"string\"}},\"required\":[\"type\",\"body\",\"answer\"],\"additionalProperties\":false},{\"type\":\"object\",\"properties\":{\"type\":{\"type\":\"string\",\"const\":\"QUESTION\"},\"question\":{\"type\":\"string\"},\"alternatives\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"order\":{\"type\":\"number\"},\"content\":{\"type\":\"string\"},\"explanation\":{\"type\":\"string\"}},\"required\":[\"order\",\"content\",\"explanation\"],\"additionalProperties\":false}},\"correctAlternativeOrder\":{\"type\":\"number\"}},\"required\":[\"type\",\"question\",\"alternatives\",\"correctAlternativeOrder\"],\"additionalProperties\":false}]}}}},\"required\":[\"elements\"],\"additionalProperties\":false},\"strict\":true,\"name\":\"response\"}},\"messages\":[{\"role\":\"user\",\"content\":\"You are an expert instructional designer. Create a comprehensive lesson plan with multiple steps about \\\"2.2.1. Mastering SELECT Statements and Clauses\\\".\\n\\n<context>\\n  <syllabus>\\n    Course: Mastering SQL: From Fundamentals to Modern Database Innovations\\n\\n1. Foundations and Historical Context of SQL\\n   1.1. The Origins and Evolution of SQL\\n      1.1.1. Historical Overview of SQL\\n      1.1.2. Pioneers and Milestones\\n      1.1.3. Evolution Timeline and Technological Impact\\n   1.2. Core Principles of Relational Databases\\n      1.2.1. Understanding the Relational Model\\n      1.2.2. Relational Algebra and Tuple Calculus\\n      1.2.3. Ensuring Data Integrity and Consistency\\n   1.3. SQL Standardization and Compliance\\n      1.3.1. Overview of ANSI and ISO Standards\\n      1.3.2. Compliance Challenges and Vendor Variability\\n      1.3.3. Standard vs. Implementation: Critical Comparisons\\n2. SQL Sublanguages and Core Operations\\n   2.1. Data Definition Language (DDL) Essentials\\n      2.1.1. Creating and Modifying Schemas\\n      2.1.2. Defining Data Types and Constraints\\n      2.1.3. Managing Indexes and Views\\n   2.2. Data Query Language (DQL) Fundamentals\\n      2.2.1. Mastering SELECT Statements and Clauses\\n      2.2.2. Filtering, Sorting, and Joining Data\\n      2.2.3. Practical Query Examples and Case Studies\\n   2.3. Data Manipulation and Control (DML & DCL)\\n      2.3.1. INSERT, UPDATE, and DELETE Operations\\n      2.3.2. Transaction Control and Rollback Mechanisms\\n      2.3.3. User Permissions and Access Controls (DCL)\\n3. Advanced SQL Concepts and Extensions\\n   3.1. Procedural Extensions and Control Flow\\n      3.1.1. Stored Procedures and User-Defined Functions\\n      3.1.2. Triggers and Automated Event Handling\\n      3.1.3. SQL/PSM and Other Procedural Extensions\\n   3.2. Advanced Query Techniques\\n      3.2.1. Subqueries and Nested Queries\\n      3.2.2. Window Functions and Aggregate Operations\\n      3.2.3. Recursive Queries and Pattern Matching\\n   3.3. Vendor-Specific Extensions and Cross-Platform Considerations\\n      3.3.1. SQL Portability and Vendor Variability\\n      3.3.2. Exploring Proprietary Extensions\\n      3.3.3. Alternatives to SQL and the Rise of NoSQL\\n4. Modern SQL Applications and Performance Best Practices\\n   4.1. SQL in the Modern Data Ecosystem\\n      4.1.1. Integrating JSON and Non-Relational Data Types\\n      4.1.2. Property Graph Queries and Advanced Data Models\\n      4.1.3. SQL in Cloud and Big Data Environments\\n   4.2. Database Design and Optimization\\n      4.2.1. Schema Design for Performance and Scalability\\n      4.2.2. Query Optimization and Indexing Strategies\\n      4.2.3. Performance Tuning and Troubleshooting\\n   4.3. Real-World Projects and Best Practices\\n      4.3.1. Case Studies of Successful SQL Deployments\\n      4.3.2. Integrating SQL with Modern Programming Frameworks\\n      4.3.3. Establishing Best Practices and Avoiding Common Pitfalls\\n\\n  </syllabus>\\n  <current-topic>\\n    <title>\\n      2.2.1. Mastering SELECT Statements and Clauses\\n    </title>\\n    <description>\\n      Students will explore the anatomy of SELECT statements, including the use of DISTINCT, FROM, WHERE, GROUP BY, and ORDER BY clauses. Detailed examples illustrate how each clause affects the query output. The topic emphasizes clarity in data retrieval and common pitfalls in clause usage. Practical exercises focus on writing and optimizing basic queries.\\n    </description>\\n    <metadata>\\n      <module-title>\\n        2.2. Data Query Language (DQL) Fundamentals\\n      </module-title>\\n      <unit-title>\\n        2. SQL Sublanguages and Core Operations\\n      </unit-title>\\n    </metadata>\\n  </current-topic>\\n  <chunks>\\n    <chunk>The SQL language is structured into several key elements, each serving a distinct purpose in the formulation of queries and statements:\\n\\n1. **Clauses**: These are the fundamental components of SQL statements and queries. While some clauses are mandatory, others may be optional, allowing for flexibility in query construction.\\n\\n2. **Expressions**: SQL expressions are capable of producing either scalar values or tables, which consist of columns and rows of data. They are essential for performing calculations and manipulating data within queries.\\n\\n3. **Predicates**: Predicates define conditions that can be evaluated using SQL's three-valued logic (3VL), which includes true, false, and unknown states. They are crucial for filtering results and controlling the flow of execution in SQL statements.\\n\\n4. **Queries**: A core element of SQL, queries are designed to retrieve data based on specified criteria. They enable users to extract meaningful information from relational databases.\\n\\n5. **Statements**: SQL statements can have lasting effects on database schemas and data. They may also control various aspects of database operations, including transactions, program flow, connections, sessions, and diagnostics. Notably, SQL statements typically conclude with a semicolon (\\\";\\\"), which serves as a statement terminator. While not universally required across all platforms, it is recognized as a standard component of SQL syntax.\\n\\n6. **Insignificant Whitespace**: In SQL, whitespace is generally disregarded, allowing for improved readability and formatting of code. This feature enables developers to structure their SQL statements in a way that enhances clarity without affecting functionality.\\n\\n### Procedural Extensions\\n\\nSQL also supports procedural extensions, which enhance its capabilities by introducing control-of-flow constructs and other programming features. These extensions allow for more complex operations and logic within SQL, bridging the gap between declarative and procedural programming paradigms. Various SQL platforms may offer proprietary extensions that further expand the language's functionality, integrating procedural and object-oriented programming elements.</chunk>\\n<chunk>| **Keywords** | **Description** |\\n| --- | --- |\\n| **As** | [Alias (SQL)](https://en.wikipedia.org/wiki/Alias_(SQL) \\\"Alias (SQL)\\\") - Used to create a temporary name for a table or column. |\\n| **Case** | [Case (SQL)](https://en.wikipedia.org/wiki/Case_(SQL) \\\"Case (SQL)\\\") - A conditional expression that allows for if-then-else logic in SQL queries. |\\n| **Create** | [Create (SQL)](https://en.wikipedia.org/wiki/Create_(SQL) \\\"Create (SQL)\\\") - A command used to create new tables, views, or other database objects. |\\n| **Delete** | [Delete (SQL)](https://en.wikipedia.org/wiki/Delete_(SQL) \\\"Delete (SQL)\\\") - A command that removes rows from a table based on specified conditions. |\\n| **From** | [From (SQL)](https://en.wikipedia.org/wiki/From_(SQL) \\\"From (SQL)\\\") - Specifies the table from which to retrieve data in a query. |\\n| **Group by** | [Group by (SQL)](https://en.wikipedia.org/wiki/Group_by_(SQL) \\\"Group by (SQL)\\\") - Used to arrange identical data into groups for aggregation. |\\n| **Having** | [Having (SQL)](https://en.wikipedia.org/wiki/Having_(SQL) \\\"Having (SQL)\\\") - A clause that filters groups based on a specified condition, often used with aggregate functions. |\\n| **Insert** | [Insert (SQL)](https://en.wikipedia.org/wiki/Insert_(SQL) \\\"Insert (SQL)\\\") - A command that adds new rows to a table. |\\n| **Join** | [Join (SQL)](https://en.wikipedia.org/wiki/Join_(SQL) \\\"Join (SQL)\\\") - Combines rows from two or more tables based on a related column. |\\n| **Merge** | [Merge (SQL)](https://en.wikipedia.org/wiki/Merge_(SQL) \\\"Merge (SQL)\\\") - A command that allows for conditional updates or inserts into a table. |\\n| **Null** | [Null (SQL)](https://en.wikipedia.org/wiki/Null_(SQL) \\\"Null (SQL)\\\") - Represents a missing or undefined value in a database. |\\n| **Order by** | [Order by](https://en.wikipedia.org/wiki/Order_by \\\"Order by\\\") - A clause that sorts the result set of a query by one or more columns. |\\n| **Over** | [Window function (SQL)](https://en.wikipedia.org/wiki/Window_function_(SQL) \\\"Window function (SQL)\\\") - Used to perform calculations across a set of table rows related to the current row. |\\n| **Prepare** | [Prepare (SQL)](https://en.wikipedia.org/wiki/Prepare_(SQL) \\\"Prepare (SQL)\\\") - A command that prepares a SQL statement for execution, enhancing performance and security. |\\n| **Select** | [Select (SQL)](https://en.wikipedia.org/wiki/Select_(SQL) \\\"Select (SQL)\\\") - The primary command used to query data from a database. |\\n| **Truncate** | [Truncate (SQL)](https://en.wikipedia.org/wiki/Truncate_(SQL) \\\"Truncate (SQL)\\\") - A command that removes all rows from a table without logging individual row deletions. |\\n| **Union** | [Set operations (SQL)](https://en.wikipedia.org/wiki/Set_operations_(SQL) \\\"Set operations (SQL)\\\") - Combines the results of two or more SELECT statements into a single result set. |\\n| **Update** | [Update (SQL)](https://en.wikipedia.org/wiki/Update_(SQL) \\\"Update (SQL)\\\") - A command that modifies existing records in a table based on specified conditions. |\\n\\nThis table provides a concise overview of key SQL keywords, along with their definitions and links to further information. Each entry is designed to stand alone while maintaining a clear context within the realm of SQL programming.</chunk>\\n<chunk>| **Keywords** | \\n| --- |\\n| - [As](https://en.wikipedia.org/wiki/Alias_(SQL) \\\"Alias (SQL)\\\")<br>- [Case](https://en.wikipedia.org/wiki/Case_(SQL) \\\"Case (SQL)\\\")<br>- [Create](https://en.wikipedia.org/wiki/Create_(SQL) \\\"Create (SQL)\\\")<br>- [Delete](https://en.wikipedia.org/wiki/Delete_(SQL) \\\"Delete (SQL)\\\")<br>- [From](https://en.wikipedia.org/wiki/From_(SQL) \\\"From (SQL)\\\")<br>- [Group by](https://en.wikipedia.org/wiki/Group_by_(SQL) \\\"Group by (SQL)\\\")<br>- [Having](https://en.wikipedia.org/wiki/Having_(SQL) \\\"Having (SQL)\\\")<br>- [Insert](https://en.wikipedia.org/wiki/Insert_(SQL) \\\"Insert (SQL)\\\")<br>- [Join](https://en.wikipedia.org/wiki/Join_(SQL) \\\"Join (SQL)\\\")<br>- [Merge](https://en.wikipedia.org/wiki/Merge_(SQL) \\\"Merge (SQL)\\\")<br>- [Null](https://en.wikipedia.org/wiki/Null_(SQL) \\\"Null (SQL)\\\")<br>- [Order by](https://en.wikipedia.org/wiki/Order_by \\\"Order by\\\")<br>- [Over](https://en.wikipedia.org/wiki/Window_function_(SQL) \\\"Window function (SQL)\\\")<br>- [Prepare](https://en.wikipedia.org/wiki/Prepare_(SQL) \\\"Prepare (SQL)\\\")<br>- [Select](https://en.wikipedia.org/wiki/Select_(SQL) \\\"Select (SQL)\\\")<br>- [Truncate](https://en.wikipedia.org/wiki/Truncate_(SQL) \\\"Truncate (SQL)\\\")<br>- [Union](https://en.wikipedia.org/wiki/Set_operations_(SQL) \\\"Set operations (SQL)\\\")<br>- [Update](https://en.wikipedia.org/wiki/Update_(SQL) \\\"Update (SQL)\\\")<br>- [With](https://en.wikipedia.org/wiki/With_(SQL) \\\"With (SQL)\\\") |\\n\\n| **Related Concepts** | \\n| --- |\\n| - [Edgar Codd](https://en.wikipedia.org/wiki/Edgar_F._Codd \\\"Edgar F. Codd\\\")<br>- [Relational Database](https://en.wikipedia.org/wiki/Relational_database \\\"Relational database\\\") |\\n\\n| **ISO/IEC SQL Parts** | \\n| --- |\\n| - [Framework](https://en.wikipedia.org/w/index.php?title=SQL/Framework&action=edit&redlink=1 \\\"SQL/Framework (page does not exist)\\\")<br>- [Foundation](https://en.wikipedia.org/w/index.php?title=SQL/Foundation&action=edit&redlink=1 \\\"SQL/Foundation (page does not exist)\\\")<br>- [Call-Level Interface](https://en.wikipedia.org/wiki/SQL/CLI \\\"SQL/CLI\\\")<br>- [Persistent Stored Modules](https://en.wikipedia.org/wiki/SQL/PSM \\\"SQL/PSM\\\")<br>- [Management of External Data](https://en.wikipedia.org/wiki/SQL/MED \\\"SQL/MED\\\")<br>- [Object Language Bindings](https://en.wikipedia.org/wiki/SQL/OLB \\\"SQL/OLB\\\")<br>- [Information and Definition Schemas](https://en.wikipedia.org/wiki/SQL/Schemata \\\"SQL/Schemata\\\")<br>- [SQL Routines and Types for the Java Programming Language](https://en.wikipedia.org/wiki/SQL/JRT \\\"SQL/JRT\\\")<br>- [XML-Related Specifications](https://en.wikipedia.org/wiki/SQL/XML \\\"SQL/XML\\\") |\\n\\n| **Related Articles** | \\n| --- |\\n| - [Database Management Systems](https://en.wikipedia.org/wiki/Database \\\"Database\\\") | \\n\\nThis structured overview provides a comprehensive look at key SQL concepts, related figures, and the various components defined by ISO/IEC standards. Each section is designed to stand alone while maintaining clarity and context, ensuring that readers can easily navigate through the information.</chunk>\\n  </chunks>\\n</context>\\n\\nImportant: Focus only on the current topic. Do not cover material from other modules in the syllabus:\\n\\nThe lesson should follow this progression:\\n1. Start with tutorial steps that introduce and explain concepts (from basic to advanced)\\n2. Include examples that demonstrate the concepts\\n3. Reinforce with questions throughout the lesson\\n4. Continue alternating between tutorials, examples, and questions\\n\\nRequired step count: 10-15 steps total\\n\\nExample pattern of steps:\\nTUTORIAL (introduce foundational concept)\\nEXAMPLE (demonstrate foundational concept)\\nQUESTION (test foundational concept)\\nQUESTION (reinforce foundational concept)\\nTUTORIAL (introduce intermediate concept)\\nEXAMPLE (demonstrate intermediate concept)\\nQUESTION (test intermediate concept)\\nQUESTION (reinforce intermediate concept)\\nEXAMPLE (demonstrate advanced application)\\nQUESTION (test advanced application)\\nTUTORIAL (deeper concept)\\nQUESTION (comprehensive application)\\n... continues\\n\\nGuidelines:\\n- Use markdown formatting in the content\\n- Make the progression logical and build upon previous knowledge\\n- Include code examples when relevant\\n- For questions, provide meaningful explanations for each alternative\\n- Stay focused on the specific topic scope\\n- Avoid covering material from other modules\\n\\nEach step must follow one of these formats:\\n\\nTUTORIAL steps should:\\n- Start with foundational concepts\\n- Use clear explanations with markdown formatting\\n- Include relevant code snippets or diagrams when needed\\n- Break down complex topics into digestible parts\\n- Format content as:\\n  {\\n    type: \\\"TUTORIAL\\\",\\n    title: \\\"Clear, concise title\\\",\\n    body: \\\"Detailed explanation in markdown\\\"\\n  }\\n\\nEXAMPLE steps should:\\n- Demonstrate practical applications\\n- Show real-world scenarios\\n- Include both the problem and its solution\\n- Explain the reasoning behind the solution\\n- Format content as:\\n  {\\n    type: \\\"EXAMPLE\\\",\\n    body: \\\"Problem description\\\",\\n    answer: \\\"Detailed solution\\\"\\n  }\\n\\nQUESTION steps should:\\n- Test understanding of previously covered concepts\\n- Have 3-4 carefully crafted alternatives\\n- Include detailed explanations for each alternative\\n- Ensure the correct alternative is clearly superior\\n- Format content as:\\n  {\\n    type: \\\"QUESTION\\\",\\n    question: \\\"Clear question text\\\",\\n    alternatives: [\\n      {\\n        order: 1,\\n        content: \\\"Alternative text\\\",\\n        explanation: \\\"Why this is/isn't correct\\\"\\n      },\\n      // ... more alternatives\\n    ],\\n    correctAlternativeOrder: number\\n  }\\n\\n<reminder>\\n  <topic-scope>\\n    Focus only on the current topic. Do not cover material from other modules.\\n    <topic-title>\\n      2.2.1. Mastering SELECT Statements and Clauses\\n    </topic-title>\\n  </topic-scope>\\n  <step-count>\\n    Required step count: 10-15 steps total\\n  </step-count>\\n</reminder>\\n\\nGenerate an array of steps that follows this structure and ensures optimal learning progression while staying strictly within the scope of the current topic.\"}]}"
  }
}
